name: Version Based Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Środowisko (production, staging)'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      image_tag:
        description: 'Tag obrazu do deploy'
        required: true
        default: 'latest'
      branch:
        description: 'Branch do deploy'
        required: true
        default: 'master'

env:
  REGISTRY: ${{ secrets.DOCKER_REGISTRY_URL }}
  APP_IMAGE: kamz8/wartkinurt  # ZMIANA: prawdziwa nazwa obrazu
  DEPLOY_PATH: /home/services/kayak-prod

jobs:
  check-image:
    runs-on: ubuntu-latest
    outputs:
      image_exists: ${{ steps.verify-image.outputs.exists }}

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch }}

      - name: Login to Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.DOCKER_REGISTRY_URL }}
          username: ${{ secrets.DOCKER_REGISTRY_USERNAME }}
          password: ${{ secrets.DOCKER_REGISTRY_PASSWORD }}

      - name: Verify image exists
        id: verify-image
        run: |
          # ZMIANA: Użyj prawdziwej nazwy obrazu
          TARGET_IMAGE="${{ secrets.DOCKER_REGISTRY_URL }}/${{ env.APP_IMAGE }}:${{ inputs.image_tag }}"
          echo "Checking: $TARGET_IMAGE"
          if docker manifest inspect "$TARGET_IMAGE" >/dev/null 2>&1; then
            echo "✅ Image exists"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "❌ Image not found"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

  trigger-build-if-needed:
    name: Trigger Build if Image Missing
    needs: check-image
    if: needs.check-image.outputs.image_exists == 'false'
    runs-on: ubuntu-latest

    steps:
      # Usunięto krok "Get workflow ID" - nie jest już potrzebny.

      - name: Trigger docker-image.yml workflow
        uses: actions/github-script@v7
        with:
          script: |
            const branch = '${{ inputs.branch }}';
            const tag = '${{ inputs.image_tag }}';

            console.log(`Triggering docker-image.yml for branch: ${branch}, tag: ${tag}`);

            try {
              // Używamy NAZWY PLIKU - to jest stabilne
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'docker-image.yml',
                ref: branch,
                inputs: {
                  branch: branch,
                  image_tag: tag,
                  additional_tags: ''
                }
              });

              console.log("✅ docker-image.yml triggered successfully!");
              console.log("⏳ Waiting 2 minutes for the image to build...");
              await new Promise(resolve => setTimeout(resolve, 120000));

            } catch (error) {
              console.error("❌ Trigger failed:", error);
              // KLUCZOWE: Użycie core.setFailed() do oznaczenia joba jako nieudanego,
              // co zablokuje job deploy
              core.setFailed("Triggering docker-image.yml failed: " + error.message);
            }
  deploy:
    needs: [check-image, trigger-build-if-needed]
    if: needs.check-image.outputs.image_exists == 'true' || needs.trigger-build-if-needed.result == 'success'
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch }}
          fetch-depth: 0

      - name: Install sshpass
        run: sudo apt-get install -y sshpass

      - name: Prepare deployment bundle
        run: |
          cp docker-compose.prod.yml docker-compose.yml
          tar -czf deploy.tar.gz docker-compose.yml

      - name: Upload deployment files
        run: |
          sshpass -p "${{ secrets.SERVER_PASSWORD }}" \
          scp -o StrictHostKeyChecking=no -P ${{ secrets.SERVER_PORT }} \
          deploy.tar.gz \
          ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:~/deploy.tar.gz

      - name: Execute deploy script on server
        env:
          REGISTRY: ${{ secrets.DOCKER_REGISTRY_URL }}
          APP_IMAGE: ${{ env.APP_IMAGE }}  # ZMIANA: używaj APP_IMAGE
          IMAGE_TAG: ${{ inputs.image_tag }}
          DEPLOY_PATH: ${{ env.DEPLOY_PATH }}
        run: |
          sshpass -p "${{ secrets.SERVER_PASSWORD }}" ssh \
            -o StrictHostKeyChecking=no \
            -p ${{ secrets.SERVER_PORT }} \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
          "set -e
           mkdir -p $DEPLOY_PATH
           mv ~/deploy.tar.gz $DEPLOY_PATH/
           cd $DEPLOY_PATH

           tar -xzf deploy.tar.gz
           rm deploy.tar.gz

           echo '${{ secrets.DOCKER_REGISTRY_PASSWORD }}' | docker login $REGISTRY -u ${{ secrets.DOCKER_REGISTRY_USERNAME }} --password-stdin

           # ZMIANA: Użyj prawdziwej nazwy obrazu
           IMAGE=$REGISTRY/$APP_IMAGE:$IMAGE_TAG
           echo 'Using image: $IMAGE'

           docker-compose pull
           docker-compose up -d --remove-orphans

           sleep 15
           docker-compose ps
          "

  health-check:
    needs: deploy
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Health check
        run: |
          for i in {1..15}; do
            if curl -fs https://wartkinurt.pl/ || curl -fs https://wartkinurt.pl/health; then
              echo "✅ App is healthy"
              exit 0
            fi
            echo "⏳ Waiting for app to start... ($i/15)"
            sleep 10
          done
          echo "❌ Health check failed"
          exit 1
