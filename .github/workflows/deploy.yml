name: Version Based Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Åšrodowisko (production, staging)'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      image_tag:
        description: 'Tag obrazu do deploy'
        required: true
        default: 'latest'
      branch:
        description: 'Branch do deploy'
        required: true
        default: 'master'

env:
  REGISTRY: ${{ secrets.DOCKER_REGISTRY_URL }}
  APP_NAME: kayak-app
  DEPLOY_PATH: /home/services/kayak-prod


jobs:
  check-image:
    runs-on: ubuntu-latest
    outputs:
      image_exists: ${{ steps.verify-image.outputs.exists }}

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch }}

      - name: Login to Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.DOCKER_REGISTRY_URL }}
          username: ${{ secrets.DOCKER_REGISTRY_USERNAME }}
          password: ${{ secrets.DOCKER_REGISTRY_PASSWORD }}

      - name: Verify image exists
        id: verify-image
        run: |
          TARGET_IMAGE="${{ secrets.DOCKER_REGISTRY_URL }}/${{ env.APP_NAME }}:${{ inputs.image_tag }}"
          if docker manifest inspect "$TARGET_IMAGE" >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi


  trigger-build-if-needed:
    name: Trigger Build if Image Missing
    needs: check-image
    if: needs.check-image.outputs.image_exists == 'false'
    runs-on: ubuntu-latest

    steps:
      - name: Get workflow ID
        id: get-workflow
        run: |
          # Pobierz listÄ™ workflow i znajdÅº ID dla "Build and Push Docker Image"
          response=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows")
          echo "Available workflows:"
          echo "$response" | jq -r '.workflows[] | "\(.name): \(.id)"'

          workflow_id=$(echo "$response" | jq -r '.workflows[] | select(.name == "Build and Push Docker Image") | .id')
          if [ -n "$workflow_id" ]; then
            echo "Found workflow ID: $workflow_id"
            echo "workflow_id=$workflow_id" >> $GITHUB_OUTPUT
          else
            echo "âŒ Workflow 'Build and Push Docker Image' not found"
            exit 1
          fi

      - name: Trigger build workflow
        uses: actions/github-script@v7
        with:
          script: |
            const branch = '${{ inputs.branch }}';
            const tag = '${{ inputs.image_tag }}';
            const workflowId = '${{ steps.get-workflow.outputs.workflow_id }}';

            console.log(`Triggering workflow ${workflowId} for branch: ${branch}, tag: ${tag}`);

            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workflowId,  // UÅ¼yj ID zamiast nazwy
                ref: branch,
                inputs: {
                  branch: branch,
                  image_tag: tag,
                  additional_tags: ''
                }
              });

              console.log("âœ… Build workflow triggered successfully!");
              console.log("â³ Waiting 2 minutes for the image to build...");
              await new Promise(resolve => setTimeout(resolve, 120000));

            } catch (error) {
              console.error("âŒ Trigger failed:", error.message);

              // Debug info
              const workflows = await github.rest.actions.listRepoWorkflows({
                owner: context.repo.owner,
                repo: context.repo.repo
              });

              console.log("ðŸ“‹ Available workflows:");
              workflows.data.workflows.forEach(wf => {
                console.log(`- ${wf.name} (ID: ${wf.id}, File: ${wf.path})`);
              });
            }
  deploy:
    needs: [check-image, trigger-build-if-needed]
    if: needs.check-image.outputs.image_exists == 'true' || needs.trigger-build-if-needed.result == 'success'
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch }}
          fetch-depth: 0

      - name: Install sshpass
        run: sudo apt-get install -y sshpass

      - name: Prepare deployment bundle
        run: |
          cp docker-compose.prod.yml docker-compose.yml
          tar -czf deploy.tar.gz docker-compose.yml

      - name: Upload deployment files
        run: |
          sshpass -p "${{ secrets.SERVER_PASSWORD }}" \
          scp -o StrictHostKeyChecking=no -P ${{ secrets.SERVER_PORT }} \
          deploy.tar.gz \
          ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:~/deploy.tar.gz

      - name: Execute deploy script on server
        env:
          REGISTRY: ${{ secrets.DOCKER_REGISTRY_URL }}
          APP_NAME: ${{ env.APP_NAME }}
          IMAGE_TAG: ${{ inputs.image_tag }}
          DEPLOY_PATH: ${{ env.DEPLOY_PATH }}
        run: |
          sshpass -p "${{ secrets.SERVER_PASSWORD }}" ssh \
            -o StrictHostKeyChecking=no \
            -p ${{ secrets.SERVER_PORT }} \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
          "set -e
           mkdir -p $DEPLOY_PATH
           mv ~/deploy.tar.gz $DEPLOY_PATH/
           cd $DEPLOY_PATH

           tar -xzf deploy.tar.gz
           rm deploy.tar.gz

           echo '${{ secrets.DOCKER_REGISTRY_PASSWORD }}' | docker login $REGISTRY -u ${{ secrets.DOCKER_REGISTRY_USERNAME }} --password-stdin

           IMAGE=$REGISTRY/$APP_NAME:$IMAGE_TAG

           docker-compose pull
           docker-compose up -d --remove-orphans

           sleep 15
           docker-compose ps
          "

  health-check:
    needs: deploy
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Health check
        run: |
          for i in {1..15}; do
            if curl -fs https://wartkinurt.pl/ || curl -fs https://wartkinurt.pl/health; then
              echo "App OK"
              exit 0
            fi
            sleep 10
          done
          echo "Health check failed"
          exit 1
