name: Version Based Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: '≈örodowisko (production, staging)'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      image_tag:
        description: 'Tag obrazu do deploy (np. latest, v1.0.0)'
        required: true
        default: 'latest'
      branch:
        description: 'Branch do deploy'
        required: true
        default: 'master'

env:
  REGISTRY: ${{ secrets.DOCKER_REGISTRY_URL }}
  APP_NAME: kayak-app
  DEPLOY_PATH: /home/services/kayak-prod

jobs:
  check-image:
    name: Check Docker Image
    runs-on: ubuntu-latest
    outputs:
      image_exists: ${{ steps.verify-image.outputs.exists }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch }}

      - name: Login to Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.DOCKER_REGISTRY_URL }}
          username: ${{ secrets.DOCKER_REGISTRY_USERNAME }}
          password: ${{ secrets.DOCKER_REGISTRY_PASSWORD }}

      - name: Verify target image exists
        id: verify-image
        run: |
          TARGET_IMAGE="${{ secrets.DOCKER_REGISTRY_URL }}/${{ env.APP_NAME }}:${{ inputs.image_tag }}"
          echo "Checking if image exists: $TARGET_IMAGE"
          
          if docker manifest inspect "$TARGET_IMAGE" > /dev/null 2>&1; then
            echo "‚úÖ Target image exists"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Target image not found"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

  trigger-build-if-needed:
    name: Trigger Build if Image Missing
    needs: check-image
    if: needs.check-image.outputs.image_exists == 'false'
    runs-on: ubuntu-latest

    steps:
      - name: Trigger Version Based Builds workflow
        uses: actions/github-script@v7
        with:
          script: |
            const tag = '${{ inputs.image_tag }}';
            const branch = '${{ inputs.branch }}';
            
            console.log(`Triggering build for tag: ${tag}, branch: ${branch}`);
            
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'version-based-builds.yml',
                ref: branch,
                inputs: {}
              });
              
              console.log('Build workflow triggered successfully');
              await new Promise(resolve => setTimeout(resolve, 120000));
              
            } catch (error) {
              console.log('Error triggering build workflow:', error.message);
            }

  deploy:
    name: Deploy Application
    needs: [check-image, trigger-build-if-needed]
    if: needs.check-image.outputs.image_exists == 'true' || needs.trigger-build-if-needed.result == 'success'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch }}
          fetch-depth: 0

      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Prepare deployment files
        run: |
          echo "üìÅ Preparing deployment files..."
          
          # Upewnij siƒô ≈ºe mamy docker-compose.prod.yml
          if [ ! -f "docker-compose.prod.yml" ]; then
            echo "‚ùå docker-compose.prod.yml not found!"
            exit 1
          fi
          
          # U≈ºyj docker-compose.prod.yml jako g≈Ç√≥wnego
          cp docker-compose.prod.yml docker-compose.yml
          echo "‚úÖ Using docker-compose.prod.yml"
          
          # Sprawd≈∫ czy mamy .env.example
          if [ -f ".env.example" ]; then
            echo "‚úÖ Found .env.example"
          else
            echo "‚ö†Ô∏è  No .env.example found"
          fi

      - name: Create deployment package
        run: |
          # Stw√≥rz archiwum z plikami do deploy
          echo "üì¶ Creating deployment package..."
          tar -czf deploy.tar.gz \
            docker-compose.yml \
            .env.example \
            --exclude='node_modules' \
            --exclude='.git' \
            --exclude='.github' \
            --exclude='*.md' \
            --exclude='tests' \
            --exclude='vendor' \
            2>/dev/null || echo "Some files missing, continuing..."
          
          echo "‚úÖ Created deployment package:"
          ls -la deploy.tar.gz

      - name: Deploy to server
        env:
          DEPLOY_PATH: ${{ env.DEPLOY_PATH }}
          REGISTRY: ${{ secrets.DOCKER_REGISTRY_URL }}
          APP_NAME: ${{ env.APP_NAME }}
          IMAGE_TAG: ${{ inputs.image_tag }}
        run: |
          set -e
          
          DEPLOY_SCRIPT=$(cat << 'SCRIPT'
          set -e
          echo "üöÄ Starting full deployment to $DEPLOY_PATH"
          
          # Stw√≥rz katalog deploy je≈õli nie istnieje
          sudo mkdir -p $DEPLOY_PATH
          sudo chown $USER:$USER $DEPLOY_PATH
          cd $DEPLOY_PATH
          
          # Wyczy≈õƒá je≈õli to pierwszy deploy (opcjonalnie)
          if [ "${{ inputs.force_redeploy }}" == "true" ]; then
            echo "üßπ Cleaning existing deployment..."
            docker-compose down 2>/dev/null || true
            sudo rm -rf ./* 2>/dev/null || true
          fi
          
          # Rozpakuj pliki deployment
          echo "üì¶ Extracting deployment files..."
          tar -xzf deploy.tar.gz
          rm -f deploy.tar.gz
          
          # Sprawd≈∫ czy ju≈º istnieje .env (≈ºeby nie nadpisaƒá istniejƒÖcej konfiguracji)
          if [ ! -f ".env" ]; then
            if [ -f ".env.example" ]; then
              echo "üìù Creating .env from .env.example"
              cp .env.example .env
              echo "‚ö†Ô∏è  Remember to configure REAL .env file with production values!"
            else
              echo "‚ùå No .env file found and no .env.example available!"
              echo "üìù Creating basic .env file..."
              cat > .env << ENV
APP_ENV=production
APP_DEBUG=false
APP_KEY=base64:temp_key_change_me_in_production
DB_CONNECTION=mysql
DB_HOST=db
DB_DATABASE=kayak_app
DB_USERNAME=root
DB_PASSWORD=change_me
REDIS_HOST=redis
QUEUE_CONNECTION=redis
CACHE_DRIVER=redis
ENV
            fi
          else
            echo "‚úÖ Using existing .env file"
          fi
          
          # Login to registry
          echo "üîê Logging to Docker registry..."
          echo "${{ secrets.DOCKER_REGISTRY_PASSWORD }}" | docker login $REGISTRY -u ${{ secrets.DOCKER_REGISTRY_USERNAME }} --password-stdin
          
          # Uruchom docker-compose
          echo "üê≥ Starting docker-compose..."
          docker-compose pull
          docker-compose up -d
          
          # Poczekaj a≈º kontenery siƒô uruchomiƒÖ
          echo "‚è≥ Waiting for containers to start..."
          sleep 30
          
          # Sprawd≈∫ status
          echo "üìä Deployment status:"
          docker-compose ps
          
          # Poka≈º logi z aplikacji
          echo "üìã Application logs:"
          docker-compose logs --tail=20 app || echo "No app logs available"
          
          echo "‚úÖ Full deployment completed successfully!"
          echo "üåê Application should be available at: https://wartkinurt.pl"
          SCRIPT
          )
          
          # Wy≈õlij pliki na serwer
          echo "üì§ Uploading deployment files to server..."
          sshpass -p "${{ secrets.SERVER_PASSWORD }}" scp -o StrictHostKeyChecking=no -P ${{ secrets.SERVER_PORT }} \
            deploy.tar.gz \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:~/deploy.tar.gz
          
          # Wykonaj deploy script
          echo "üõ†Ô∏è Executing deployment script..."
          sshpass -p "${{ secrets.SERVER_PASSWORD }}" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} -p ${{ secrets.SERVER_PORT }} "$DEPLOY_SCRIPT"

      - name: Verify deployment
        run: |
          echo "üèÅ Deployment completed"
          echo "Environment: ${{ inputs.environment }}"
          echo "Branch: ${{ inputs.branch }}"
          echo "Image: ${{ secrets.DOCKER_REGISTRY_URL }}/${{ env.APP_NAME }}:${{ inputs.image_tag }}"
          echo "Deploy path: ${{ env.DEPLOY_PATH }}"
          echo "Server: ${{ secrets.SERVER_HOST }}:${{ secrets.SERVER_PORT }}"

  health-check:
    name: Health Check
    needs: deploy
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Check application health
        run: |
          echo "üîç Performing health check..."
          max_attempts=15
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            echo "Attempt $attempt of $max_attempts..."
            if curl -f https://wartkinurt.pl/ 2>/dev/null || 
               curl -f https://api.wartkinurt.pl/ 2>/dev/null || 
               curl -f https://wartkinurt.pl/health 2>/dev/null; then
              echo "‚úÖ Health check passed - application is responding"
              exit 0
            fi
            echo "‚è≥ Waiting 10 seconds..."
            sleep 10
            attempt=$((attempt + 1))
          done
          
          echo "‚ùå Health check failed after $max_attempts attempts"
          echo "Application might still be starting up..."
          exit 1
