name: Version Based Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Åšrodowisko (production, staging, development)'
        required: true
        default: 'staging'
        type: choice
        options:
          - production
          - staging
          - development
      image_tag:
        description: 'Tag obrazu do deploy (np. latest, v1.0.0, develop)'
        required: true
        default: 'latest'
      force_redeploy:
        description: 'WymuÅ› redeploy nawet jeÅ›li wersja jest taka sama'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: registry.wartkinurt.pl
  APP_NAME: kayak-app

jobs:
  check-deployment:
    name: Check Deployment Status
    runs-on: ubuntu-latest
    outputs:
      needs_deploy: ${{ steps.check.outputs.needs_deploy }}
      current_version: ${{ steps.check.outputs.current_version }}
      target_version: ${{ steps.check.outputs.target_version }}
      image_exists: ${{ steps.verify-image.outputs.exists }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Verify target image exists
        id: verify-image
        run: |
          TARGET_IMAGE="${{ env.REGISTRY }}/${{ env.APP_NAME }}:${{ inputs.image_tag }}"
          echo "Checking if image exists: $TARGET_IMAGE"
          
          if docker manifest inspect "$TARGET_IMAGE" > /dev/null 2>&1; then
            echo "âœ… Target image exists"
            echo "exists=true" >> $GITHUB_OUTPUT
            
            # Pobierz SHA obrazu
            IMAGE_SHA=$(docker inspect "$TARGET_IMAGE" --format='{{index .Config.Labels "org.opencontainers.image.revision"}}' 2>/dev/null || echo "")
            echo "image_sha=$IMAGE_SHA" >> $GITHUB_OUTPUT
          else
            echo "âŒ Target image not found"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Check current deployment (via SSH with password)
        if: inputs.force_redeploy != 'true'
        id: check
        run: |
          # Install sshpass for password authentication
          sudo apt-get update && sudo apt-get install -y sshpass
          
          # SprawdÅº aktualnie dziaÅ‚ajÄ…cy kontener
          CURRENT_IMAGE=$(sshpass -p "${{ secrets.SERVER_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "docker ps --filter 'name=${{ env.APP_NAME }}-${{ inputs.environment }}' --format '{{.Image}}' 2>/dev/null || echo ''")
          echo "Current running image: $CURRENT_IMAGE"
          
          TARGET_IMAGE="${{ env.REGISTRY }}/${{ env.APP_NAME }}:${{ inputs.image_tag }}"
          echo "Target image: $TARGET_IMAGE"
          
          if [[ "$CURRENT_IMAGE" == "$TARGET_IMAGE" ]]; then
            echo "âš ï¸  Same version already deployed"
            echo "needs_deploy=false" >> $GITHUB_OUTPUT
          else
            echo "âœ… Different version detected, deployment needed"
            echo "needs_deploy=true" >> $GITHUB_OUTPUT
          fi
          
          echo "current_version=$CURRENT_IMAGE" >> $GITHUB_OUTPUT
          echo "target_version=$TARGET_IMAGE" >> $GITHUB_OUTPUT

  trigger-build-if-needed:
    name: Trigger Build if Image Missing
    needs: check-deployment
    if: needs.check-deployment.outputs.image_exists == 'false'
    runs-on: ubuntu-latest

    steps:
      - name: Determine branch from tag
        id: branch-detector
        run: |
          TAG="${{ inputs.image_tag }}"
          if [[ "$TAG" == "latest" ]]; then
            echo "branch=master" >> $GITHUB_OUTPUT
          elif [[ "$TAG" == "develop" ]]; then
            echo "branch=develop" >> $GITHUB_OUTPUT
          else
            # Dla tagÃ³w wersji - sprÃ³buj znaleÅºÄ‡ odpowiedni branch
            echo "branch=master" >> $GITHUB_OUTPUT
          fi

      - name: Trigger Version Based Builds workflow
        uses: actions/github-script@v7
        with:
          script: |
            const tag = '${{ inputs.image_tag }}';
            const branch = '${{ steps.branch-detector.outputs.branch }}';
            
            console.log(`Triggering build for tag: ${tag}, branch: ${branch}`);
            
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'version-based-builds.yml',
              ref: branch,
              inputs: {}
            });
            
            console.log('Build workflow triggered successfully');
            
            // Czekaj na ukoÅ„czenie builda (uproszczone)
            console.log('Waiting 60 seconds for build to complete...');
            await new Promise(resolve => setTimeout(resolve, 60000));

  deploy:
    name: Deploy to ${{ inputs.environment }}
    needs: [check-deployment, trigger-build-if-needed]
    if: |
      (needs.check-deployment.outputs.needs_deploy == 'true' || inputs.force_redeploy == 'true') &&
      (needs.check-deployment.outputs.image_exists == 'true' || needs.trigger-build-if-needed.result == 'success')
    runs-on: ubuntu-latest

    steps:
      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Deploy application
        env:
          REGISTRY: ${{ env.REGISTRY }}
          APP_NAME: ${{ env.APP_NAME }}
          IMAGE_TAG: ${{ inputs.image_tag }}
          ENVIRONMENT: ${{ inputs.environment }}
        run: |
          sshpass -p "${{ secrets.SERVER_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
          # Login to registry
          echo "${{ secrets.REGISTRY_PASSWORD }}" | docker login $REGISTRY -u ${{ secrets.REGISTRY_USERNAME }} --password-stdin
          
          # Pull latest image
          echo "Pulling image: $REGISTRY/$APP_NAME:$IMAGE_TAG"
          docker pull $REGISTRY/$APP_NAME:$IMAGE_TAG
          
          # Stop and remove old container
          echo "Stopping old container: ${APP_NAME}-${ENVIRONMENT}"
          docker stop ${APP_NAME}-${ENVIRONMENT} || true
          docker rm ${APP_NAME}-${ENVIRONMENT} || true
          
          # Run new container with environment-specific settings
          echo "Starting new container: ${APP_NAME}-${ENVIRONMENT}"
          docker run -d \
            --name ${APP_NAME}-${ENVIRONMENT} \
            --restart unless-stopped \
            -p 80:3000 \
            -e NODE_ENV=production \
            -e APP_ENV=$ENVIRONMENT \
            $REGISTRY/$APP_NAME:$IMAGE_TAG
          
          # Clean up unused images
          docker image prune -f
          
          echo "âœ… Deployment to $ENVIRONMENT completed successfully"
          EOF

      - name: Verify deployment
        run: |
          echo "ðŸ Deployment verification"
          echo "Environment: ${{ inputs.environment }}"
          echo "Image: ${{ env.REGISTRY }}/${{ env.APP_NAME }}:${{ inputs.image_tag }}"
          echo "Server: ${{ secrets.SERVER_HOST }}"
          echo "Application should be available at: http://${{ secrets.SERVER_HOST }}"

  health-check:
    name: Health Check
    needs: deploy
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Check application health
        run: |
          echo "ðŸ” Performing health check..."
          # Prosty health check HTTP
          if curl -f http://${{ secrets.SERVER_HOST }}/health || curl -f http://${{ secrets.SERVER_HOST }}; then
            echo "âœ… Health check passed"
          else
            echo "âŒ Health check failed"
            exit 1
          fi
